ROADMAP

v0.5
-> fix current tests ok
-> 80% API documentation ok 
-> cardinality operator ok
-> tests for operands
-> export multiple variables ok

v0.6
-> conflict detection from "use" 
-> namespace ok, (using package)
-> tests for statements

v0.8

-> templates
-> last integration stuff with Entropy

v0.9
-> HTML manual
-> emacs stuff
-> 100% API documentation
-> > 90% code covered by tests

v0.98:
-> isolated elements considered as a singleton in the constraint signature only


v0.99:
-> integration as a plugin for entropy-2.1

v1.0
-> tutorial, manual
-> tests++


Etendre un peu le language pour gagner en concision en proposant l'opérateur [..] pour spécifier des ensembles de variables par exemple, et des for pour jouer avec.

Exemple:

$T1 = VM[1..2];
$T2 = VM[5..10];
$T3 = VM[17, 18, 20];
spread($T1);
spread($T2);
spread($T3);
	
Deviendrait:

$T1 = VM[1..2];
$T2 = VM[5..10];
$T3 = VM[17, 18, 20];
for $t in $T[1..3] {
    spread($t);
}

for $n in [rennes, grenoble, orsay, toulouse, nice, sophia]-frontend {
    ban($n, $ALL_VMS);
}

for $r in $R[1..10] {
    capacity($r, 100);
}

-> ajouter nombres en base 10 et en hexa
$P1 = n[0x5..0xF] <=> $P1 = {n5, n6, n7, n8, n9, nA, nB, nC, nD, nE, nF};
$P2 = $T1 - $T2;
$x = 5 - 7 + pastel-3; //Erreur de type
$c = 10;

---
Ajouter un opérateur pour la cardinalité des sets |s| ou #s
$T1 = VM[1..5];
$size = |$T1|;

Opérateur de division /
Opérateur de soustraction -

structures conditionnelles:
if (|$T1| >= 10) {
   mostlySpread(|$T1|, 5);
} else {
  spread($T1);
}

//Definition en extension:
$T = {VM1, VM2, VM3};
$BT = {$T1, $T2, $T3};

//Definition par une suite
//On autorise les entiers en base 10, 8 et 16
$T = VM[1..3]; //$T = {VM1, VM2, VM3}
$BT = $T[1..3]; //$BT = {$T1, $T2, $T3};
$u = VM[0xa .. 0xf]; //$u = {VMa, VMb, VMc, VMd, VMd, VMf};

//Enumeration
$T = VM[1,2,3];
$BT = $T[1,2,3];

//Addition 
$ALL_VMS = $T[1 +..+ 3]; //$ALL_VMS = $T1 + $T2 + $T3;
$ALL_VMS = VM[1 + .. + 3]; //Error. Ne marche que sur des ensembles ou des nombres

Operations sur les sets

Addition
$T1 = {vm1, vm2};
$T2 = {vm3, vm4};
$TT = $T1 + $T2; //$TT = {vm1, vm2, vm3, vm4}

Soustraction
$T1 = {vm1, vm2}
$X = $T1 - {vm1}; //$X = {vm2};

Division:
$S = VM[1..100];
$subs = $S / 4; // $subs = {VM[1..25], VM[26..50], VM[51..75], VM[76..100]};

Cardinalité
$T1 = VM[1..10];
$size = |$T1|; //$size == 10;


Structures conditionnelles
if

else if

else

Iterations
for $i in {1, 2, 3} {
    
}

//Décomposition
{$R1,$R2,$R3,$R4} = $ALL_NODES/4; //Que passa si plus de 5 sets ?
$R[1..4] = $ALL_NODES/50;
$R[1..] = $ALL_NODES/50; //numérotation automatique

{$R1, $R2, $R3, $R4} = $ALL_NODES/4;
{$R1,,$R3,} = $ALL_NODES/5; 



//User costs in the file ?
//What are they: start, stop: cause they are related to the content of the VMs
//while migrate, suspend, resume are more infrastructure cost

//Definition during the instantiation ?

namespace myAppliation;

import datacenter;

VM[1..10] : tinyInstance<volatile,start=5,stop=7>; //startup time = 5 seconds, stoptime=7
VM[11..20] : microInstance<preemptible,start=10,stop=20>;
VM[21..24] : largeMemoryInstance;

$T1 = VM[1..10];
$T2 = VM[11..20];
$T3 = VM[21..24];

lonely($T[1..3]);
for $t in $T[1..3] {
    spread($t);
}

among($T3, $R[1..7]);

-- Options --

- volatile
- preemptible
- start (int)
- stop (int)
- destroyable -> plan can kill the VM instead of shutting it properly


Friendly description:
- For security purpose, you can specify
the namespaces allowed to used some exported variables.
Concept similar ot friendly methods/classes in C++;

Sample:

---
export $racks to clients.*;
---

Here, the variable $racks will be available to any namespaces
belonging to clients.

By default, the variable is exported to anyone importing the
namespace


NODE TEMPLATE/PLATFORM CONSTRAINT

Purpose
	-> indicates characteristics the plan module does not know:
	   - the available hosting platform
	   - the drivers
	   - the transition cost associated to each platform
	   - the management options associated to each platform

-> template or collection of templates ?

One generic command to change the template, commands per template after
to manipulate the node or its VMs

@pc[1..30]: vmware<install=40>,xen<install=30>;
@pc[1..31]: vmware<install=60>,xen<install=70>;

//Force platforms
platform(@pc24, xen);

-> is a VM platform encoded in hard in its template or is not related
to its template. So some platform are better than others ?



-> each node template translated to an integer
O(n)

-> each VM indicates its type, translated to an integer

-> ensure a VM will be placed on a compatible node
d_x^h = y -> n_y^t = d_x^t

All is constant yet, so a serie of fence is just fine !
-> as a result, should partitioning naturally

-> What for reconfigurable nodes ?

@pc1 : xen<install=60,boot=10, shutdown=7>, kvm<install=30,boot=10, shutdown=5>;
@pc2: xen<install=60>;
@pc3 : kvm<install=30>;


Still have to ensure d_x^h = y -> n_y^t = d_x^t
BUT this time, n_y^t is a variable
HOWEVER, d^t is a constant

Placement part:
  pc_1^t: <0, 1>;
  pc_35^t: <0,1>;
  pc_45^t: <1>;

vm_1^t = 0;
vm_2^t = 1;
vm_3^t = 1;
vm_4^t = 1;

Properties:
- all the VMs on a node have the same type.
 \forall d_i,d_j \in \m{D} | d_i^h = d_j^h = x , d_i^t = d_j^t \wedge 

\in n_x^t
 d_x^h = y -> n_y^t = d_x^t

 

TRAFFIC CONSTRAINT:
Similar problem than in the File Transfer Problem:
limit the number of incomings/outgoings/both at a same moment to increase practical efficiency

Import and variables

import clients.*;
-> creation of $clients as a unique set and $clients.* as a set of each subnamespace ?

Nice to have:
for $c in $clients {
    fence ($c, $partitions[$i]);
    $i = $i++ % #$partitions;
}




Node State management

-> Some nodes are manageable and their state could be
handled by Entropy

e.g: to turn off idle servers
to boot a node when their is no enough online nodes

-> a bootable node:
  + a offline node
  -> if a VM has to go on this node, it will be booted

  -> a c-slice with a cost depending on whether a VM comes on the node or not
  cost: 0||k

-> a shutdownable node:
  -> if the node is online and does not host any VM, then it can be turned off

shutdownIdles(ns : nodeset):

foreach n (ns[manageable]) {
	occurence(d-slices,card)
	card == 0 <=> idle = 0
	end >= idle * shutdown(n)
	globalCost : idle * shutdown(n)
}


ManageableNodeActionModel
getNode() : Node
willBeOnline() : IntDomainVar


if (isOnline(n)) { //It may be turned off
  cost = {0,d}
  toHalt = 
} else { //It may be turned on
  getUsedMemory(n) > 0 -> required
  cost = {0,d}
  end = cost;
  required -> cost = d;
  (willBeOnline = required)
}
Online(ns : ManagedElementSet<Node>) {
	  for (Node n : ns) {
	  model.willBeOnline.setVal(1);
}
}


ShutdownableNodeActionModel {

isOnline == 1 //Will be online, no action, no duration, no cost
  start() = rp.end()
isOnline == 0 //Will be offline, shutdown action, cost = getEnd(), duration=K
  start
}

action:
end() = rp.getEnd();
duration() > K
cost() > K

force -> getUsedMem() == 0


onlineCapacity(nodeset, nb) => custom unit (Memory, cpu, ...)
=> At most nb nodes onlines. Power consumption, licences, ...

spareNodes(nodeset, nb)
=> nb idles node onlines to be able to quickly answer to load spike

offline(nodeset)
=> every nodes must be offline

online(nodeset)
=> every nodes must be online

idleOffline(nodeset)
=> every online node that do not host any VM must be offline (power consumption, licences, ...)


on planMySlices
an exclusive n:1 association:
 n c-slices : 1 d-slice
d-slice not known at instantiation

Parser tool
  -> print dependency tree

./btrp dep foo.btrp

foo.btrp
|
\_ dc.btrp

./btrp valid

./btrp reformat

./btrp check

Constraint checker

./btrp check foo.btrp

-> Check if there is no contradiction in foo.btrp

-> how to deal with dependencies:
  -> check there is no contradiction in the dependencies
  -> then check for contradiction when we add this vjob



1/

-> Ajouter un checker de faisabilité:
on vérifie si une solution est possible d'après une spec
1/ un fichier, sans configuration: configuration taille infinie
   -> detecte non faisabilité, contraintes conflictuelles comme fence sur ensemble vide, spread + gather
2/ un fichier, une config sans mes VMs, ...
   -> check en plus placement absolue, reference vers des noeuds non existants
3/ un fichier, une config avec mes VMs
   -> check avec ressources
4/ un fichier, une config avec mes VMs et d'autres VMs
   -> check avec ressources restantes actuellement ?
  -> on considère que les autres resteront ou elles sont
Utiliser BtrPlace pour déployer sur G5K

Features:
-> Creation noeuds depuis OAR_NODEFILE
-> templates g5k
-> copy on write sur image de base
-> 1 NFS par site

-> no intersite migration
