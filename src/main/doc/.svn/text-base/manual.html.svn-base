<h1>BtrPlace Specification Language Manual</h1>

<p>The btrplace specification language (btrpsl) is a descriptive language
    to specify constraints related to the placement of virtual machines
    in a datacenters.</p>

<p>This language is dedicated to datacenters administrators and applications administrators
    that use <a href="http://entropy.gforge.inria.fr">Entropy</a> to manage their nodes and virtual machines.</p>

<h2>General structure</h2>

<p>The structure of a BtrPlace script is quite common:
    - a statement ends with ";"
    - C-style (//) and C++-style (/* */) comments are allowed</p>

<h2>Values</h2>

<p>Btrplace support only three kinds of values: integer, nodes and VMs. Here, a node or a VM value point to the
    identifier of a VM. It can be its name or its UUID.</p>

<h3>Integers</h3>

<p>BtrPlace supports decimal integers, octal integers and hexadecimal integers. The following is a pseudo EBNF defining
    the accepted integers:</p>

<p>integer = decimal<em>integer | octal</em>integer | hex<em>integer .
    decimal</em>integer = ( "1" .. "9" ) ( decimal<em>digit )* .
    octal</em>integer = "0" ( octal<em>digit )* .
    hex</em>integer = "0" ( "x" | "X" ) hex<em>digit hex</em>digit* .
    decimal<em>digit = "0" ... "9" .
        octal</em>digit = "0" ... "7" .
    hex_digit = "0" ... "9" | "A" ... "F" | "a" ... "f" .</p>

<p>Here is some example of valid integers :</p>

<p>
    <source lang="perl">
    42
    0600
    0xBadFace
    1701411
    </source></p>

<h3>Virtual Machines (VMs) and nodes</h3>

<p>VMs and nodes are considered as values by btrPlace. A value is then either the textual name of the element or its
    UUID.</p>

<p>Currently, there is no namespace for the elements, which means each element must have a unique name. At least two
    namespace (one for the VMs, one for the nodes) will be available later. The syntax to specify the name of an element
    is mostly equivalent to the RFC XXX specifying domain names. Only the character "-" is prohibited inside a name.
    Another solution to specify an element is to use its UUID[REF]. The following is the pseudo EBNF that specify a VM
    or node identifier:</p>

<p>element = uuid | litteral .
    uuid = "u" hex<em>digit{8} "-" hex</em>digit{4} "-" hex<em>digit{4} "-" hex</em>digit{4} "-" hex<em>digit{12} .
        letter = "a" .. "z" | "a" .. "z";
        domain = letter (letter|decimal</em>digit)<em>;
        litteral = domain ("." domain)</em>;</p>

<p>Here is some valid identifiers for VMs or nodes:</p>

<p>
    <source lang="perl">
    u12345678-1234-EAD2-AAED-234F-1234567890AB
    node1
    node1.myDatacenter.com
    </source></p>

<h2>Variables</h2>

<p>A variable is always prefixed by a dollar "$" character. The following is the pseudo EBNF that specify a variable
    identifier:</p>

<p>variable = "$" letter (letter|decimal_digit)*;</p>

<p>Here is some valid variable names :</p>

<p>
    <source lang="perl">
    $foo
    $Bar
    $foo2
    </source></p>

<p>Before being use, a variable must be defined.</p>

<h2>Types</h2>

<p>Btrplace is not explicitly typed. The type of each litteral is inferred by the interpreter. Currently, accepted types
    are constant and set.</p>

<h3>Constant type</h3>

<p>A constant type denotes an integer, a node or a VM. The type of the variable is then inferred from the type of the
    specified constant.
    If a variable is redefined, its type can be changed. In the following examples, litterals starting with "VM" are VMs
    while litteral starting with "N" are nodes.</p>

<p>
    <source lang="perl">
    $V1 = VM1; //$V1 has constant type VM
    $V2 = N2; //$V2 has constant type node
    $V1 = N3; //Now $V1 has constant type Node
    </source></p>

<h3>Set type</h3>

<p>A set is an ordered suite of unique elements. An element is either a constant or a set. However, elements in a same
    set must have the same type.
    Sets can be defined either in extension, using a range or an enumeration of elements. The following is the pseudo
    EBNF that specify a set.</p>

<p>set = exploded | range | enum .
    content = set | element | integer .
    exploded = "{" element* "}" .
    range = .
    enum = .</p>

<p>In the following examples, litterals starting with "VM" are VMs while litteral starting with "N" are nodes.</p>

<p>
    <source lang="perl">
    $T1 = {VM1, VM2, VM3}; //$T1 is a set of 3 VMs
    $T2 = {0xFF, 5}; //$T2 is a set of 2 integers
    $T3 = {N1}; //$T3 is a set composed of 1 node.
    </source></p>

<p>Following set definition are not accepted</p>

<p>
    <source lang="perl">
    {VM1, N2, VM3}; // We can not mix elements with different type, here, 2 VMs and 1 node
    {VM1, {VM2, VM3}}; //We can not mix constants with sets
    {{VM1, VM2}, {{VM3}}}; //Here the set is not homogeneous. All the subsets does not have the same depth.
    </source></p>

<h2>Properties of variables and values</h2>

<ul>
    <li><p>Two sets are equals if there content is equivalent, without consideration of their order</p></li>
    <li><p>Variables are equals if there content are equivalent</p></li>
</ul>

<h2>Variables and values</h2>

<p>=== Supported values ===
    Btrplace manages nodes and VMs. Their identifier, is then considered as a value. nodes and virtual machines are then
    supposed to
    have a unique name to prevent conflicts. In addition, supported values are integer than can be expressed in
    different bases.</p>

<ul>
    <li>node or virtual machine name:</li>
    <li>base 10 integer:</li>
    <li>base 16 integer:</li>
</ul>

<h3>Variables</h3>

<p>Variables are prefixed with a dollar sign ($). There is no need to declare them. Variables are not explicitly typed,
    the type is
    inferred from its content.</p>

<h3>Sets</h3>

<p>Btrplace massively relies on set theory and most of the variables are sets. This is a necessary as a lot of
    constraints
    manipulate set of virtual machines or set of nodes. Several primitives are then available to easily specify sets
    and manipulate them. Primitives relies mostly on definition of range of element using common naming convention
    and set theory to compose sets.</p>

<p>A set may be build in several way, either in extension, using a range of nodes or using union.</p>

<h3>Set definition</h3>

<p>'''in extension'''</p>

<p>
    <source lang="perl">
    $S1 = {VM1, VM2, VM3, VM4}
    </source></p>

<p>Here, we define a set in extension and make the variable \$S1 points on it. The set is composed
    of 4 elements, named VM1, VM2, VM3, and VM4</p>

<p>'''using range of nodes'''</p>

<p>
    <source lang="perl">
    $S2 = VM[1..4]
    $S3 = V[M1, 3]
    </source></p>

<p>Here, we define the set using a range of elements and make the variable \$S2 points on it. We only
    specify the start and the end of the range in braces. This will create a value per possible increment.
    \$S2 will then contains 4 elements, named VM1, VM2, VM3, and VM4. The set \$S3 is
    also defined with a range of nodes, but with an enumeration. Here, it will be composed of
    the elements VM1 and VM3.</p>

<h3>Operations on values</h3>

<p>Traditional arithmetic operations are available between numbers: addition '+', substraction '-', mutliplication '<em>',
    division '/', remainder '%', and power '^'
    <source lang="perl">
    $x = 5 + 2</em> 3; //$x == 11
    $y = $x % 3; //$y == 2
    $z = -$y^3; //$z == -8
    </source></p>

<h3>Operations on sets</h3>

<p>Arithmetic operations ease the manipulation of set of elements.</p>

<p>'''Union of sets using '+' '''</p>

<p>Traditional union between two sets having the same type. Duplicates elements are ignored.</p>

<p>
    <source lang="perl">
    $T1 = {VM1, VM2, VM3, VM4};
    $T2 = {VM4, VM5};
    $RES = $T1 + $T2; // $RES == {VM1, VM2, VM3, VM4, VM5};
    </source></p>

<p>'''Difference of sets using '-''''</p>

<p>Traditional difference between two sets having the same type. Elements in the right operand that are not in the left
    operand
    are ignored.</p>

<p>
    <source lang="perl">
    $T1 = {VM1, VM2, VM3, VM4};
    $T2 = {VM4, VM5};
    $RES = $T1 - $T2; // $RES == {VM1, VM2, VM3};
    </source></p>

<p>'''Dividing a set using '/''''</p>

<p>An operator two split a set into a specific number of partitions.
    The result is a set containing each partition. The number of elements in each
    partition has to be balanced to the possible.</p>

<p>
    <source lang="perl">
    $set = {{VM1, VM2}, {VM3, VM4}, {VM5, VM6}, {VM7}, {VM8, VM9}};
    $partitions = $set / 3; //$partitions == { {{VM1, VM2}, {VM3, VM4}}, {{VM5, VM6}, {VM7}}, {{VM8, VM9}} };
    </source></p>

<p>'''Exploding a set using '\''''
    An operator to split a set into several partitions having at most the given size. Partitions must be filled to the
    possible.</p>

<p>
    <source lang="perl">
    $set = {VM1, VM2, VM3, VM4, VM5, VM6, VM7, VM8, VM9};
    $partitions = $set \ 4; //$partitions == { {VM1, VM2, VM3, VM4}, {VM5, VM6, VM7, VM8}, {VM9}};
    </source></p>

<p>'''Cartesian product of two sets using '*''''</p>

<p>Common cartesian product. The two operand must have the same type and degree</p>

<p>
    <source lang="perl">
    $T1 = {VM1, VM2};
    $T2 = {VM3, VM4};
    $RES = $T1 * $T2; //$RES == {{VM1, VM3}, {VM1, VM4}, {VM2, VM3}, {VM2, VM4}};
    </source></p>

<p>'''Cardinality of a set using '|''''</p>

<p>An operator to get the number of elements composing a set</p>

<p>
    <source lang="perl">
    $T1 = {{VM2, VM3}, {VM4}};
    $x = |$T1|; //$x == 2
    </source></p>

<h2>Decomposition of a set</h2>

<p>It is possible to decompose a set by performing some bindings between a set of variables and a common set. This also
    allow to declare several variables simultaneously.</p>

<p>Using the equals '=' operator, it is possible to specify several variables pointing to some elements of a set.
    In the following example, we assign the variables \$R1 to \$R3 to each elements composing \$X.</p>

<p>
    <source lang="perl">
    $X = {N[1..10], N[11..20], N[21..30]};
    {$R1, $R2, $R3} = $X; //$R1 == N[1..10]; $R2 == N[11..20]; $R3 == [N21..30];
    </source></p>

<p>It is not a requirement to have the number of elements resulting decomposed set equals to
    the number of elements composing the set to decompose. If the sets in the left operand have fewer elements,
    then additional elements in the right set will be ignored. If the cardinality of the left set is superior to the
    cardinality
    of the right set, then empty sets are created :</p>

<p>
    <source lang="perl">
    $X = {N[1..10], N[11..20], N[21..30]};
    {$R1, $R2} = $X; //$R1 == N[1..10]; $R2 == N[11..20];
    {$R5, $R6, $R7, $R8} = $X; //$R5 == N[1..10]; $R6 == N[11..20]; $R7 == [N21..30]; $R8 == {}
    </source></p>

<p>''''The blank identifier''''</p>

<p>As in Go, the blank identifier is available to ignore a value when decomposing a set. In this situation,
    no binding to a variable is done</p>

<p>
    <source lang="perl">
    $X = {N[1..10], N[11..20], N[21..30]};
    {$R1,_,$R3} = $X; //$R1 == N[1..10]; $R3 == N[21..30];
    </source></p>

<p>Finally, definition using range of variables or enumeration of variables is possible when defining multiple variables
    from a set decomposition.</p>

<p>
    <source lang="perl">
    $ALL<em>NODES = N[1..100];
    $R[1..4] = $ALL</em>NODES / 4;
    /*
    $R1 = N[1..25];
    $R2 = N[26..50];
    $R3 = N[51..75];
    $R4 = N[76..100];
    */
    </source></p>

<h2>Constraint</h2>

<p>In Btrplace, a constraint can be assimilated to a common function in a programming language.
    Each constraint has a unique name then a list of parameters given in parentheses.</p>

<p>'''Constraint signature''</p>

<p>The signature of each constraint is provided. it defines the name of the constraint and the list
    of its accepted parameters. Each parameter must be typed. The following is the signature for a pseudo-constraint
    named ''foo''</p>

<p>
    <source lang="perl">
    foo(vs : vmset, ns : nodeset, x : int)
    </source></p>

<p>The constraint ''foo'' takes 3 arguments as parameters. The first has to be a vmset ( a set of virtual machines),
    the second parameter must be a nodeset ( a set of nodes), and the last parameter must be an int (an integer)</p>

<p>'''Type inferring'''</p>

<p>The following example show the usage of the constraint ''foo''.</p>

<p>
    <source lang="perl">
    $S1 = VM[1..3];
    $S2 = {N1, N2, N3};
    foo($S1, $S2, 5);
    </source></p>

<p>Here, we first define the sets \$S1 and \$S2 then we instantiate the constraint ''foo''. At this moment,
    the set \$S1 is typed as a vmset, the set \$S2 is typed as a nodeset and 5 is typed as an integer.</p>

<h2>Pre-defined variables</h2>
