<h1>Tutorial</h1>

<p>This document is a tutorial introduction to the basics of btrp. It is not a comprehensive
    guide to the language; at this moment the document closest to that is the <a href="manual.html">Manual</a>.</p>

<p>All the scripts described here are available in the <code>examples</code> directory and should work out of the box.
</p>

<h2>Hello (Virtual) World</h2>

<p>Let's start with the traditional useless examples to show the basics. This script is available in
    'helloVWorld.btrp':</p>

<pre><code>namespace helloVWorld;

    {VM1, VM2, VM3, VM4} : tiny;

    $VMS = VM[1..4];
    spread($VMS);
    lonely($VMS);
</code></pre>

<p>This sample script declares the vjob 'example.helloWorld'. It first asks for four instances of the
    virtual machines template 'tinyInstance'. Then, the variable '$VMS' is defined and associated to
    the VMs VM1 to VM4. Finally, two placement constraints are specified. With 'spread', the VMs have
    to be deployed on distinct nodes. With 'lonely', the VMs will not be colocated with VMs other than
    VM1, VM2, VM3, or VM4.</p>

<h3>Running the script</h3>

<p>To run it, just type:</p>

<pre><code>$ ./btrplint valid examples/helloVWorld.btrp
</code></pre>

<p>If btrplace is installed successfully, you should read something like this:</p>

<pre><code>example.helloVWorld{
    vms: {example.helloVWorld.VM1, example.helloVWorld.VM2, example.helloVWorld.VM3, example.helloVWorld.VM4}
    nodes: {}
    exported: {}
    constraints:
    cSpread({example.helloVWorld.VM1, example.helloVWorld.VM2, example.helloVWorld.VM3, example.helloVWorld.VM4})
    }
</code></pre>

<p>In an error is printed on screen or if the exit code of <code>btrp</code> is different to 0, then it may be an error
    in
    your installation or you are just unlucky as the example is be outdated. Here, the resulting output is
    the vjob that has been created for Entropy.</p>

<h3>HelloVWorld, step by step</h3>

<p>The 'namespace' instruction specifies the identifier of the vjob. This must be the first line
    of the script. The last element of the namespace <strong>must be</strong> the name of the script, without the
    '.btrp' extension.</p>

<p>After the namespace declaration, we define a set of 4 virtual machines, labeled from VM1 to VM4. The virtual machines
    are types to be an instance of the <code>tiny</code> template. A template specifies the size of a virtual machine.
    In particular, its maximum resource consumption.</p>

<p>Each VM identifier in a namespace has to be unique. However it is restricted to the current namespace. So any
    identifier
    as a local name and a fully qualified name. Here, 'VM1' is the local name of the identifier while
    'example.helloVWorld.VM1'
    is the fully qualified name. So, one can have a same local identifier in different namespace.</p>

<p>Third line declares a variable, named <code>$VMS</code>. Every variable starts with the dollar sign (<code>$</code>).
    The variable
    is assigned to a set defined using a range of elements. Here, it is composed of the elements named from VM1 to VM4.
</p>

<p>Last two lines declare a placement constraint. Here, each of the constraint takes only one argument as a parameter,
    that
    is a set of virtual machines.</p>

<h2>Advanced utilization</h2>

<p>The first example describes a sample vjob that can be managed by Entropy. This section presents a more
    complex example, using most of the construction facilities of the language. All the files are in the
    'example/advanced'
    folder.</p>

<p>This example first specifies a datacenter infrastructure. This infrastructure is then used by several application
    administrators that want to have some vjobs deployed on it. Last, the datacenter administrator also have
    some placement expectations related to the management of the datacenter.</p>

<p>To run the following examples. Either launch them from the directory <code>examples/advanced</code> or include <code>examples/advanced</code>
    in the includes path.</p>

<h3>Specification of the datacenter</h3>

<p>The sample datacenter is composed of 256 servers stacked by 50 into racks. The script <code>examples/advanced/datacenter.btrp</code>
    makes
    the description.</p>

<pre><code>namespace datacenter;

    $servers = @srv-[0x1..0xff, frontend];

    $racks = $servers % 50;

    export $racks to *;
    export $servers to admin.*;
</code></pre>

<p>The variable <code>$server</code> is declared and point to the set of servers. An element is considered as a server
    if it starts
    with the arobace character <code>@</code>. The name of a server should be its hostname. In that sense, it is not
    related to the
    namespace of the vjob.</p>

<p>The set is defined using a sequence of
    elements generated with an hexadecimal iteration, and an enumeration. The set will be composed of 256 servers: from
    'srv-1' to 'srv-ff' and 'srv-frontend'.</p>

<p>On the next line, the set pointed by $server is parted into sets of 50 elements to represent the different racks that
    composed the infrastructure. The variable <code>$racks</code> is declared to point to the resulting set.
    <code>$racks</code> may also be written the following way:</p>

<pre><code>$racks = {@srv-[0x1..0x32], @srv-[0x33..0x64],
    @srv-[0x65..0x96], @srv-[0x97..0xC8],
    @srv-[0xC9..0xFA], @srv-[0xFB..0xFF]} + {@srv-frontend}};
</code></pre>

<p>The variables declared here may be useful by the clients or the datacenter administrator to express placement
    constraints. So the last two lines export theses variables using the <code>export</code> keyword.
    <code>$racks</code> will be available for
    anyone. <code>$servers</code> will be available for any vjobs that belong to the namespace <code>admin</code>.</p>

<p>Further informations about elements composing this declaration: <a href="namespace.html">namespace</a>, <a
        href="set.html">set definition</a>,
    <a href="export.html">export</a></p>

<h3>Specification of a client vjob</h3>

<p>Here, we consider an application administrator that want to deploy a highly-available 3-tiers application on the
    datacenter. Every replicas in a tier have to be deployed on a distinct node to provide fault tolerance, while the
    service running in the last tier is stateful and should be placed on nodes closely connected to provide a good
    network
    latency to their synchronization protocol. The example script is available into <code>examples/advanced/clients/app1.btrp</code>.
</p>

<pre><code>namespace clients.app1;

    import datacenter;

    VM[1..30] : large&lt;clone, boot=10, halt=5&gt;;

    $T[1..3] = VM[1..30] / 3;

    for $t in $T[1..3] {
    spread($t);
    }

    root($me);
    among($T3,$racks);

    export $me to admin.*;
</code></pre>

<p>Here, the application administrator uses the <code>import</code> keyword to import all the exported variables from
    <code>datacenter</code>.
    So, the variable <code>$racks</code> will be available in this script, but not the variable <code>$servers</code> as
    the export restriction
    is not satisfied.</p>

<p>The administrator asks then for 30 VMs of type <code>large</code>. Each instantiation is then parametrized with 3
    options.
    First, <code>clone</code> indicates to the plan module that the VMs can be re-instantiated to its new location when
    the live
    migration is not cost effective. <code>boot</code> and <code>halt</code> options indicate then the estimated boot
    and halt duration of the VM.</p>

<p>3 variables are then created to point to the 3 tiers of the application. For this example, we use a set division
    and multiple assignment to be more concise. We assign one variable to one set by specifying a set of 3 variables on
    the
    left side and a set splitted up in 3 sets on the right side. This is equivalent to the followings :</p>

<pre><code>{$T1, $T2, $T3} = VM[1..30] % 3;
    {$T1, $T2, $T3} = {VM[1..10], VM[11..20], VM[21..30]};
</code></pre>

<p>To maintain fault tolerance to hardware
    failures, all the VMs that belong to a same tier must be on distinct servers. The <code>spread</code> constraints is
    available
    for that purpose. Here, using a loop, the administrator specifies one constraint per tier. The <code>for</code> loop
    allows to
    iterate over a set. Here, the set is dynamically constructed using a range of variable, <code>$T[1..3]</code> is
    then equivalent
    to <code>{$T1, $T2, $T3}</code>.</p>

<p>With the constraint <code>root</code>, the administrator disallows the VMs in the variable <code>$me</code> to be
    moved from their current
    server if they are already running. The variable <code>$me</code> is a special variable that is created
    automatically when
    the script is interpreted. It is a set that contains all the VMs declared in the script.</p>

<p>With the constraint <code>among</code>, the administrator indicates that all the VMs from $T3 must be one exactly one
    set of
    servers, among the sets given in <code>$racks</code>. This is motivated by the service that is running the third
    tier.</p>

<p>The last line uses the <code>export</code> statement to export all the VMs belonging to the vjob using the
    <code>$me</code> variable.
    There will be available using a variable with a name equals to the namespace of the vjob. This will allow the
    datacenter
    administrator to administrate its datacenter. In practice, this line may be added automatically once the vjob
    submmitted
    to be sure that the datacenter administrator will be available to manage the vjob.</p>

<p>Further informations about elements composing this declaration: <a href="import.html">import</a>, <a
        href="template.html">template</a>,
    <a href="for.html">for</a>, <a href="constraints.html">constraints</a></p>

<h3>Datacenter administrator constraints</h3>

<p>Last script of this advanced tutorial denotes a system administrator that want to express some placement constraints
    related to the use of its datacenter. The example script is available into
    <code>examples/advanced/admin/app1.btrp</code>.</p>

<pre><code>namespace admin.sysadmin;

    import datacenter;
    import clients.*;

    entropy : large;

    root(entropy);
    fence(entropy,@srv-frontend);
    lonely(entropy);

    fence($clients, $servers - {@srv-frontend});

    for $rack in $racks {
    capacity($rack, 1000);
    }

    for $n in $servers {
    capacity($n, 10);
    }

    ban($clients, @srv-210);
</code></pre>

<p>First, the datacenter administrator imports the datacenter namespace as it will operate on the infrastructure,
    then he imports all the namespace belonging to clients. A variable <code>$clients</code> is then automatically
    created
    and contains every VMs that was exported by the vjobs belonging to the <code>clients</code> namespace.</p>

<p>The administrator run Entropy in a virtual machine. The virtual machine, named <code>entropy</code>, is an instance
    of the
    <code>large</code> template.</p>

<p>Using a <code>root</code> constraint, it disallows the VMs to be moved as it may distrib the VM performance. The
    virtual machine
    is then fenced on the node <code>srv-frontend</code> using a <code>fence</code> constraint. Last, the VM is isolated
    from all the others
    VMs in the datacenter using the <code>lonely</code> constraint. This is motivated by a security purpose: the
    datacenter
    administrator want to have the clients VMs and the service VMs on distinct nodes to avoid a local exploit that
    break an hypervisor, attack a service VM for a client VM.</p>

<p>The <code>fence</code> constraint indicates the clients VMs are fenced into the servers in <code>$servers</code>
    minus the server
    <code>srv-frontend</code>. Note that is constraint is redundant. Indeed, with the previous <code>lonely</code> and
    <code>root</code> constraint, no
    clients VMs may be deployed on <code>srv-frontend</code>.</p>

<p>Using <code>capacity</code> constraints, the datacenter administrator restricts first the maximum hosting capacity of
    each
    rack to 1000 VMs and the hosting capacity of each server to 10 VMs.</p>

<p>Finally, a <code>ban</code> constraint is used to remove and prevent all the clients VMs to be hosted on the server
    <code>srv-210</code>.
    This is for a maintenance purpose. Once the server will be available again, this constraint will be removed.</p>

<h2>Exporting a script for Entropy</h2>

<p>Every valid script can be exported in a file format accepted by entropy. Currently, <code>btrp</code> supports the
    XML file format
    and the protobuf file format. The conversion is available from the <code>btrp</code> executable. Just asks to write
    the resulting
    script into a file ending with <code>.pbd</code> or <code>.xml</code> to make the conversion.</p>

<pre><code>$ ./btrplint valid -I examples/advanced -o sysadmin.xml examples/advanced/admin/sysadmin.btrp
</code></pre>

<p>Each script that will be converted into XML or pbd is standalone. So every dependencies will be included in the
    resulting file.</p>
