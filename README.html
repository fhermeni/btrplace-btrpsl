<h1>Btrplace Specification Language</h1>

<p>The btrplace specification language (btrpsl) allows to express constraints
    related to the placement of virtual machines in a datacenters.</p>

<p>This language is dedicated to datacenters administrators and applications administrators
    that use <a href="http://entropy.gforge.inria.fr">Entropy</a> to manage their nodes and virtual machines.</p>

<h2>Features</h2>

<p>This language massively relies on set theory and common naming conventions of the
    VMs and the nodes to provide an concise definition of sets. Placement
    constraints allow then describe the expected placement without having to burden about
    the details.</p>

<h2>Installation Notes</h2>

<p>Btrpsl works as a standalone application or as a plugin for <a href="http://entropy.gforge.inria.fr">Entropy</a>.</p>

<h3>Installation as a standalone application</h3>

<p><code>btrplint</code> aims to execute btrpsl scripts. To install
    the application, just declare the environment variable <code>BTRP_HOME</code> pointing
    to the installation directory of btrpsl. If the variable is not declared,
    they the current working directory will be used. Just type <code>btrp</code> to get the
    available command line options.</p>

<h3>Installation as a plugin for Entropy</h3>

<p>btrpsl can be used as an input to declare vjobs into entropy. There is no need
    to recompile entropy:</p>

<ul>
    <li><p>put the jar 'btrpsl' in this 'jar' directory to the 'jar' directory of entropy.</p></li>
    <li><p>copy the sample 'btrpVjobs.properties' into the config directory of Entropy. You
        can then specify the constraints to load and the paths to consider as possible
        includes. By default, only the current working directory is scanned where
        the builder is looking for vjobs description.</p></li>
    <li><p>in the config directory of Entropy. Append 'btrp' into the list of builders to load
        and specify the location of the class (here, 'xml' and 'pbd' builders were already
        declared).</p>

        <p>vjobBuilders.load=xml,pbd,btrp</p>

        <p>vjobBuilders.location.xml=entropy.vjob.builder.xml.XMLVJobBuilderBuilder
            vjobBuilders.location.pbd=entropy.vjob.builder.protobuf.ProtobufVJobBuilderBuilder
            vjobBuilders.location.btrp=btrpsl.BtrPlaceVJobBuilderBuilder</p></li>
</ul>

<p>Entropy should now be able to load vjobs written in btrPlace once restarted.</p>

<h2>Basic examples</h2>

<p>The folder <code>examples</code> contains some example scripts. Once installed,
    just type the following command to execute the sample script <code>vappAH.btrp</code>:</p>

<pre><code>btrPlaceSL$ ./btrplint valid -I examples/includes examples/vappHA.btrp
</code></pre>

<h3>Describing a datacenter</h3>

<p>The following example specifies a datacenter composed of 251 nodes. Nodes
    are stacked by 40 into racks. 250 of the nodes are working nodes, dedicated
    to the hosting of client. They are labelled from "node-1" to "node-250".
    The last node is a service node and run some service VMs. This node is labelled
    "node-frontend". The whole datacenter can not run more than 2000 VMs
    simultaneously while each node can not host more than 15 VMs at the same time.</p>

<pre><code>namespace datacenter;

    $nodes = @node-[1..250,frontend];
    capacity($nodes, 2000);

    for $n in $nodes {
    capacity($n, 15);
    }

    $R[1..7] = $nodes % 40;

    export $nodes,$R[1..7] to *;
</code></pre>

<h3>Describing a virtualized application</h3>

<p>Following example is a specification from a application administrator
    that describes a 3-tiers Web applications. Each replica of a same
    tier should be placed on a distinct nodes for fault tolerance to hardware
    failures, while the last tier must be running into a single rack to have a
    low latency. Last, the application administrator does not want its VMs to be
    collocated with other VMs for security purpose.</p>

<pre><code>namespace myApplication;

    import datacenter;

    VM[1..10] : tinyInstance&lt;clone,boot=7,halt=10&gt;;
    VM[11..20] : microInstance&lt;destroyable&gt;;
    VM[21..24] : largeMemoryInstance;

    $T1 = VM[1..10];
    $T2 = VM[11..20];
    $T3 = VM[21..24];

    lonely(VM[1..24]);
    for $t in $T[1..3] {
    spread($t);
    }

    among($T3, $R[1..7]);
</code></pre>

<p>A drafty and badly written tutorial about the language is available in the <code>doc</code> directory. A complete
    manual
    for the language, including its specifications and other examples will be available ... one day.</p>

<h2>Copyright</h2>

<p>Copyright (c) 2011 Fabien Hermenier. See <code>LICENSE.txt</code> for details.</p>
